!# ==================================================================================================
# GITHUB WORKFLOW: MASTER CI/CD PIPELINE (ZUSAMMENGEFÃœHRT)
#
# BESCHREIBUNG:
# Diese Pipeline ist die zentrale Automatisierung fÃ¼r das BurniToken-Projekt.
# Sie wurde aus mehreren alten Workflows (main-ci-cd.yml, production.yml, monitoring.yml, format.yml, automation-integrity-check.yml) 
# konsolidiert, um Redundanz zu beseitigen und einen klaren, autarken Prozess zu schaffen.
#
# FEATURES:
# 1.  **CI (Continuous Integration):**
#     - LÃ¤uft bei jedem Pull Request auf den `main`-Branch.
#     - Installiert AbhÃ¤ngigkeiten.
#     - FÃ¼hrt Linting, Tests, einen Security-Audit und einen IntegritÃ¤tscheck durch.
#     - FÃ¼hrt Lighthouse-Audits (Performance, SEO, Accessibility) direkt im PR durch.
#     - Blockiert das Merging, wenn einer dieser Schritte fehlschlÃ¤gt.
#
# 2.  **CD (Continuous Deployment):**
#     - LÃ¤uft NUR bei einem direkten Push auf den `main`-Branch (z.B. nach einem Merge).
#     - Erstellt einen Produktions-Build der Anwendung.
#     - VerÃ¶ffentlicht die gebaute Seite automatisch auf GitHub Pages.
#
# 3.  **Repository-Verwaltung & Wartung:**
#     - LÃ¤uft tÃ¤glich, um veraltete ("stale") Issues und Pull Requests zu finden und zu schlieÃŸen.
#     - Formatiert den Code automatisch bei Pushes auf den `main`-Branch.
#
# ==================================================================================================

name: âœ… CI/CD Master Pipeline
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  schedule:
    # LÃ¤uft tÃ¤glich um Mitternacht UTC
    - cron: '0 0 * * *'
  workflow_dispatch:

jobs:
  # ===================================================================
  # JOB 1: PR-Validierung & Tests
  # ===================================================================
  validate-pr:
    name: ðŸ§ª PR Validierung & Tests
    # Dieser Job lÃ¤uft nur auf Pull Requests, nicht bei direkten Pushes auf main
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - name: 1. Code auschecken
        uses: actions/checkout@v4

      - name: 2. Node.js Umgebung aufsetzen (v22)
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'

      - name: 3. AbhÃ¤ngigkeiten installieren
        run: npm ci

      - name: 4. Code-Formatierung prÃ¼fen (Linting)
        run: npm run lint:check --if-present

      - name: 5. Tests ausfÃ¼hren
        run: npm test

      - name: 6. Security Audit durchfÃ¼hren
        run: npm audit

      - name: 7. Automation Integrity Check
        run: node tools/final-automation-audit.js

      - name: 8. Lighthouse-Audits durchfÃ¼hren
        run: |
          npm install -g @lhci/cli
          npx lhci autorun --config=./lighthouserc-performance.js || echo "Lighthouse Performance audit failed"
          npx lhci autorun --config=./lighthouserc-seo.js || echo "Lighthouse SEO audit failed"
          npx lhci autorun --config=./lighthouserc-accessibility.js || echo "Lighthouse Accessibility audit failed"

      - name: 9. Lighthouse-Berichte hochladen
        uses: actions/upload-artifact@v3
        with:
          name: lighthouse-reports
          path: ./.lighthouseci/

  # ===================================================================
  # JOB 2: Build & Deploy
  # ===================================================================
  build-and-deploy:
    name: ðŸš€ Build & Deploy
    # Dieser Job lÃ¤uft nur bei Pushes auf den main-Branch
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    # Braucht die Ergebnisse von validate-pr, wenn es ein PR-Merge war (implizit)
    # Bei direktem Push gibt es keine AbhÃ¤ngigkeit.
    steps:
      - name: 1. Code auschecken
        uses: actions/checkout@v4

      - name: 2. Node.js Umgebung aufsetzen (v22)
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'

      - name: 3. AbhÃ¤ngigkeiten installieren
        run: npm ci

      - name: 4. Produktions-Build erstellen
        run: npm run build --if-present

      - name: 5. Build-Output Ã¼berprÃ¼fen
        run: |
          echo "ÃœberprÃ¼fe den Inhalt des Build-Verzeichnisses..."
          ls -la
          if [ ! -f "index.html" ]; then
            echo "Fehler: index.html wurde nicht im Stammverzeichnis gefunden!"
            exit 1
          fi
          echo "Validierung erfolgreich: index.html gefunden."

      - name: 6. Auf GitHub Pages verÃ¶ffentlichen
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          # Der Build-Output landet im Stammverzeichnis, nicht in 'dist'.
          publish_dir: ./

  # ===================================================================
  # JOB 3: Repository-Wartung (Auto-Format & Stale Issues)
  # ===================================================================
  repository-maintenance:
    name: ðŸ§¹ Repository Wartung
    # LÃ¤uft nach Zeitplan ODER bei Push auf main
    if: github.event_name == 'schedule' || (github.event_name == 'push' && github.ref == 'refs/heads/main')
    runs-on: ubuntu-latest
    steps:
      # Schritt 1: Code auschecken (wird fÃ¼r beide Jobs benÃ¶tigt)
      # Wichtig: Wir verwenden den Bot-Token, um Push-Rechte zu haben.
      - name: 1. Code mit Bot-Token auschecken
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GEMINI_BOT_TOKEN }}

      # Schritt 2: Veraltete Issues und PRs mit Bot-IdentitÃ¤t schlieÃŸen
      - name: 2. Veraltete Issues & PRs schlieÃŸen (nur bei schedule)
        if: github.event_name == 'schedule'
        uses: actions/stale@v9
        with:
          repo-token: ${{ secrets.GEMINI_BOT_TOKEN }}
          stale-issue-message: 'Dieses Issue ist seit 60 Tagen inaktiv und wird aus GrÃ¼nden der Ãœbersichtlichkeit vom Bot geschlossen. Bei Bedarf bitte neu Ã¶ffnen.'
          stale-pr-message: 'Dieser Pull Request ist seit 60 Tagen inaktiv und wird vom Bot geschlossen. Bei Bedarf bitte neu erstellen.'
          days-before-stale: 60
          days-before-close: 7

      # Schritt 3: Code automatisch formatieren und committen
      - name: 3. Code formatieren & committen (nur bei push)
        id: format_and_commit # ID hinzugefÃ¼gt, um auf den Output zugreifen zu kÃ¶nnen
        if: github.event_name == 'push'
        run: |
          # Git mit den Bot-Informationen konfigurieren
          git config --global user.name 'GeminiAiChefDev'
          git config --global user.email 'gemini-ai-chef-dev@users.noreply.github.com'
          
          # AbhÃ¤ngigkeiten installieren und Code formatieren
          npm ci
          npm run lint:fix --if-present
          
          # PrÃ¼fen, ob es Ã„nderungen gibt, und nur dann committen & pushen
          if ! git diff-index --quiet HEAD; then
            echo "Ã„nderungen gefunden, erstelle Commit..."
            git add .
            git commit -m "Chore: Automatische Code-Formatierung durch Gemini-Bot"
            git push
            echo "changes_committed=true" >> $GITHUB_OUTPUT
          else
            echo "Keine FormatierungsÃ¤nderungen erforderlich."
            echo "changes_committed=false" >> $GITHUB_OUTPUT
          fi

      # Schritt 4: Eine Ã¼bersichtliche Zusammenfassung erstellen
      - name: 4. AktivitÃ¤ts-Zusammenfassung erstellen
        if: always() # Dieser Schritt lÃ¤uft immer, um eine Zusammenfassung zu garantieren
        run: |
          echo "### ðŸ¤– Bot-AktivitÃ¤tsbericht (`${{ github.event_name }}`)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if ( '${{ github.event_name }}' == 'schedule' ); then
            echo "#### ðŸ§¹ Job: Veraltete Issues & PRs" >> $GITHUB_STEP_SUMMARY
            echo "- Der Job zur ÃœberprÃ¼fung inaktiver Issues und PRs wurde erfolgreich ausgefÃ¼hrt." >> $GITHUB_STEP_SUMMARY
            echo "- Eventuelle Aktionen (Kommentare, SchlieÃŸungen) sind direkt in den jeweiligen Issues/PRs sichtbar." >> $GITHUB_STEP_SUMMARY
          fi

          if ( '${{ github.event_name }}' == 'push' ); then
            echo "#### ðŸ’… Job: Automatische Code-Formatierung" >> $GITHUB_STEP_SUMMARY
            if ( '${{ steps.format_and_commit.outputs.changes_committed }}' == 'true' ); then
              echo "- **Status:** âœ… Ã„nderungen wurden formatiert und committet." >> $GITHUB_STEP_SUMMARY
              echo "- **Aktion:** Ein neuer Commit wurde zum `main`-Branch hinzugefÃ¼gt." >> $GITHUB_STEP_SUMMARY
            else
              echo "- **Status:** â„¹ï¸ Keine Ã„nderungen erforderlich." >> $GITHUB_STEP_SUMMARY
              echo "- **Aktion:** Der Code war bereits korrekt formatiert." >> $GITHUB_STEP_SUMMARY
            fi
          fi
