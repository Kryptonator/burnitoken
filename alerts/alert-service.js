const path = require('path');
require('dotenv').config({ path: path.resolve(__dirname, '../config.secrets') });

// alerts/alert-service.js
// Zentrale Alert-Funktion für kritische Fehler/Status (E-Mail und Webhook)
const nodemailer = require('nodemailer');
const https = require('https');
const url = require('url');
const fs = require('fs');
const { createGitHubIssue } = require('../tools/github-issue-creator');
const ALERT_LOG = path.join(__dirname, 'logs/alert.log');

async function sendAlert({
  message,
  webhookUrl,
  email,
  level = 'error',
  createIssue = false,
  extra = {},
}) {
  if (!message) return;

  const payload = {
    text: `[${level.toUpperCase()}] ${message}`,
    ...extra,
  };

  // Logge Alert zusätzlich in Datei
  try {
    fs.appendFileSync(
      ALERT_LOG,
      `[${new Date().toISOString()}] [${level.toUpperCase()}] ${message}\n`,
    );
  } catch (e) {
    /* ignore */
  }

  // GitHub Issue erstellen, falls gefordert
  if (createIssue) {
    try {
      const issueTitle = `Automatischer Alert: ${message.substring(0, 80)}`;
      const issueBody = `**Level:** ${level.toUpperCase()}\n\n**Meldung:**\n${message}\n\n**Zusätzliche Daten:**\n\`\`\`json\n${JSON.stringify(extra, null, 2)}\n\`\`\``;
      await createGitHubIssue(issueTitle, issueBody, [level, 'autogenerated']);
    } catch (error) {
      console.error('Fehler beim Erstellen des GitHub Issues direkt aus dem Alert-Service:', error);
    }
  }

  // E-Mail senden
  if (email) {
    const transporter = nodemailer.createTransport({
      service: 'yahoo',
      auth: {
        user: process.env.ALERT_EMAIL_USER || 'burn.coin@yahoo.com',
        pass: process.env.ALERT_EMAIL_PASS || 'DEIN_APP_PASSWORT',
      },
    });

    const mailOptions = {
      from: process.env.ALERT_EMAIL_USER || 'burn.coin@yahoo.com',
      to: email,
      subject: `[ALARM] ${level.toUpperCase()} - BurniToken Recovery/Status`,
      text:
        `Automatische Benachrichtigung (BurniToken Recovery/Status):\n\n${message}` +
        (extra && Object.keys(extra).length
          ? '\n\nZusatzinfos:\n' + JSON.stringify(extra, null, 2)
          : '') +
        '\n\nBitte prüfen Sie umgehend das System!',
    };

    // Promise zurückgeben, damit der Aufrufer auf das Ergebnis warten kann
    return new Promise((resolve, reject) => {
      transporter.sendMail(mailOptions, (error, info) => {
        if (error) {
          console.error('E-Mail-Alert-Fehler:', error);
          reject(error);
        } else {
          console.log('E-Mail-Alert gesendet:', info.response);
          resolve(info);
        }
      });
    });
  }

  // Webhook senden (optional)
  if (webhookUrl) {
    const parsedUrl = url.parse(webhookUrl);
    const data = JSON.stringify(payload);
    const req = https.request(
      {
        hostname: parsedUrl.hostname,
        path: parsedUrl.path,
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Content-Length': data.length,
        },
      },
      (res) => {},
    );
    req.on('error', (e) => {
      console.error('Alert-Webhook-Fehler:', e);
    });
    req.write(data);
    req.end();
    return Promise.resolve(); // Sofort resolven, da wir nicht auf Antwort warten
  }

  // Fallback, wenn kein Transportweg konfiguriert ist
  if (!email && !webhookUrl) {
    console.error('ALERT (kein Transport konfiguriert):', payload);
  }

  return Promise.resolve(); // Fallback-Promise
}

module.exports = { sendAlert };
