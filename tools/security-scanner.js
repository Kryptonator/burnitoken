// tools/security-scanner.js
/**
 * Security Scanner
 * 
 * Führt einen Sicherheitsscan des Projekts durch (z.B. mit npm audit)
 * und meldet gefundene Schwachstellen.
 */

const { exec } = require('child_process');
const { sendAlert } = require('./alert-service');
const { createGitHubIssue } = require('./github-issue-creator');

const SCAN_ID = 'security-scan';
const SCAN_NAME = 'Abhängigkeits-Sicherheitsscan';

/**
 * Führt 'npm audit' aus und analysiert das Ergebnis.
 */
async function runSecurityScan() {
    console.log('====================================================');
    console.log('🛡️  SICHERHEITSSCAN WIRD GESTARTET');
    console.log('====================================================');

    return new Promise((resolve, reject) => {
        exec('npm audit --json', { maxBuffer: 1024 * 5000 }, (error, stdout, stderr) => {
            // npm audit gibt einen non-zero-Exit-Code zurück, wenn Schwachstellen gefunden werden.
            // Wir müssen den Fehler hier anders behandeln als bei einem echten Ausführungsfehler.
            if (stdout) {
                try {
                    const auditData = JSON.parse(stdout);
                    handleAuditResults(auditData);
                    resolve(auditData);
                } catch (parseError) {
                    const errorMessage = `Fehler beim Parsen der npm audit-Ausgabe: ${parseError.message}`;
                    console.error(`❌ ${errorMessage}`);
                    triggerCriticalError(SCAN_NAME, errorMessage, parseError.stack);
                    reject(new Error(errorMessage));
                }
            } else {
                // Echter Fehler bei der Ausführung
                const errorMessage = `Fehler bei der Ausführung von 'npm audit': ${error ? error.message : stderr}`;
                console.error(`❌ ${errorMessage}`);
                triggerCriticalError(SCAN_NAME, errorMessage, error ? error.stack : stderr);
                reject(new Error(errorMessage));
            }
        });
    });
}

/**
 * Verarbeitet die Ergebnisse von npm audit.
 * @param {object} auditData - Die JSON-Ausgabe von npm audit.
 */
async function handleAuditResults(auditData) {
    const vulnerabilities = auditData.vulnerabilities;
    const summary = auditData.metadata.vulnerabilities;

    if (summary.total === 0) {
        console.log('✅ SUCCESS: Keine bekannten Sicherheitslücken in den Abhängigkeiten gefunden.');
        return;
    }

    const message = `Sicherheitsscan abgeschlossen. ${summary.total} Schwachstellen gefunden (${summary.critical} kritisch, ${summary.high} hoch).`;
    console.warn(`⚠️  ${message}`);

    // Alert senden
    await sendAlert({
        message: message,
        level: 'error',
        extra: summary
    });

    // GitHub Issue erstellen
    const issueTitle = `[Security Scan] ${summary.total} Schwachstellen gefunden`;
    let issueBody = `**Der automatische Sicherheitsscan hat ${summary.total} Schwachstellen in den Projekt-Abhängigkeiten identifiziert.**\\n\\n`;
    issueBody += `| Kritikalität | Anzahl |\\n|---|---|\\n`;
    issueBody += `| Kritisch | ${summary.critical} |\\n`;
    issueBody += `| Hoch | ${summary.high} |\\n`;
    issueBody += `| Mittel | ${summary.moderate} |\\n`;
    issueBody += `| Niedrig | ${summary.low} |\\n`;
    issueBody += `| Info | ${summary.info} |\\n\\n`;
    issueBody += `**Details:**\\n\\n`;

    for (const name in vulnerabilities) {
        const vuln = vulnerabilities[name];
        issueBody += `### ${vuln.name} (via ${vuln.via.map(v => typeof v === 'string' ? v : v.name).join(', ')})\\n`;
        issueBody += `- **Schweregrad:** ${vuln.severity}\\n`;
        issueBody += `- **Betroffene Versionen:** ${vuln.range}\\n`;
        issueBody += `- **Weitere Infos:** [${vuln.source}](${vuln.source})\\n\\n`;
    }
    
    issueBody += `*Bitte führen Sie \`npm audit fix\` aus oder aktualisieren Sie die Pakete manuell.*`;

    await createGitHubIssue(issueTitle, issueBody, ['security', 'bug', 'autogenerated']);
}

/**
 * Löst einen kritischen Fehler aus, wenn das Skript selbst fehlschlägt.
 * @param {string} source - Die Quelle des Fehlers.
 * @param {string} errorMessage - Die Fehlermeldung.
 * @param {string} stackTrace - Der Stack Trace.
 */
async function triggerCriticalError(source, errorMessage, stackTrace) {
    const issueTitle = `Kritischer Fehler im ${source}`;
    const issueBody = `Ein unerwarteter Fehler ist im Skript aufgetreten.\\n\\n**Fehler:**\\n\`\`\`${errorMessage}\`\`\`\\n\\n**Stack Trace:**\\n\`\`\`${stackTrace}\`\`\``;
    await sendAlert({ message: issueTitle, level: 'critical' });
    await createGitHubIssue(issueTitle, issueBody);
}


// Direkter Aufruf für Testzwecke
if (require.main === module) {
    runSecurityScan().catch(err => {
        // Fehler werden bereits in den Funktionen behandelt
    });
}

module.exports = { runSecurityScan };
