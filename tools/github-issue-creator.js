require('dotenv').config();
// tools/github-issue-creator.js
/**
 * GitHub Issue Creator
 *
 * Erstellt automatisch ein GitHub Issue bei kritischen Systemfehlern.
 * Verwendet die GitHub API und ben√∂tigt ein GITHUB_TOKEN.
 *
 * Erstellt: 2025-06-25
 */

const https = require('https');

// --- Konfiguration ---
// GitHub Repository (owner/repo)
let GITHUB_REPO = process.env.GITHUB_REPO;
if (!GITHUB_REPO) {
  GITHUB_REPO = 'Kryptonator/burnitoken'; // Fallback
  console.log(
    `‚ö†Ô∏è  Hinweis: GITHUB_REPO ist nicht in der .env-Datei konfiguriert. Es wird der Standardwert '${GITHUB_REPO}' verwendet.`,
  );
}
const GITHUB_OWNER = process.env.GITHUB_OWNER || GITHUB_REPO.split('/')[0];
// GitHub-Token aus den Umgebungsvariablen laden
const GITHUB_TOKEN = process.env.GITHUB_TOKEN;

/**
 * Sucht nach offenen GitHub Issues mit einem √§hnlichen Titel.
 * @param {string} title - Der Titel des zu suchenden Issues.
 * @returns {Promise<Object|null>} - Das gefundene Issue-Objekt oder null.
 */
async function findExistingIssue(title) {
  if (!GITHUB_TOKEN) return null;

  // Suche nach offenen Issues mit exaktem Titel-Match im Repository
  const query = `repo:${GITHUB_REPO} is:issue is:open in:title "${title}"`;
  const encodedQuery = encodeURIComponent(query);

  const options = {
    hostname: 'api.github.com',
    path: `/search/issues?q=${encodedQuery}`,
    method: 'GET',
    headers: {
      Authorization: `token ${GITHUB_TOKEN}`,
      'User-Agent': 'burnitoken-monitoring-service',
      Accept: 'application/vnd.github.v3+json',
    },
  };

  return new Promise((resolve, reject) => {
    const req = https.request(options, (res) => {
      let responseBody = '';
      res.on('data', (chunk) => (responseBody += chunk));
      res.on('end', () => {
        if (res.statusCode === 200) {
          const searchResult = JSON.parse(responseBody);
          if (searchResult.total_count > 0) {
            resolve(searchResult.items[0]); // Gib das erste gefundene Issue zur√ºck
          } else {
            resolve(null); // Kein passendes Issue gefunden
          }
        } else {
          console.error(`Fehler bei der Issue-Suche. Status: ${res.statusCode}`);
          resolve(null); // Bei Fehler null zur√ºckgeben, um den Prozess nicht zu blockieren
        }
      });
    });
    req.on('error', (error) => {
      console.error('Fehler bei der GitHub API-Anfrage (Suche):', error);
      resolve(null);
    });
    req.end();
  });
}

/**
 * Erstellt ein neues GitHub Issue, aber nur, wenn noch kein √§hnliches existiert.
 * @param {string} title - Der Titel des Issues.
 * @param {string} body - Der Inhalt des Issues (Markdown-formatiert).
 * @param {string[]} [labels=[]] - Ein Array von Labels, die dem Issue hinzugef√ºgt werden sollen.
 * @returns {Promise<string>} - Die URL des neu erstellten oder gefundenen Issues.
 */
async function createGitHubIssue(title, body, labels = ['bug', 'autogenerated']) {
  if (!GITHUB_TOKEN) {
    const errorMessage =
      'Fehler: GITHUB_TOKEN ist nicht gesetzt. Das Issue kann nicht erstellt werden.';
    console.error(`‚ùå ${errorMessage}`);
    return Promise.reject(new Error(errorMessage));
  }

  const existingIssue = await findExistingIssue(`[Automatisch gemeldet] ${title}`);
  if (existingIssue) {
    const message = `‚úÖ Duplikat gefunden. Ein Issue mit diesem Titel existiert bereits: ${existingIssue.html_url}`;
    console.log(message);
    // Optional: Hier k√∂nnte man einen Kommentar zum bestehenden Issue hinzuf√ºgen
    return Promise.resolve(existingIssue.html_url); // URL des bestehenden Issues zur√ºckgeben
  }

  const issueData = JSON.stringify({
    title: `ü§ñ [Automatisch gemeldet] ${title}`,
    body: `${body}\n\n---\n*Dieses Issue wurde automatisch vom System-Monitoring erstellt.*`,
    labels: labels,
    assignees: [GITHUB_OWNER],
  });

  const options = {
    hostname: 'api.github.com',
    path: `/repos/${GITHUB_REPO}/issues`,
    method: 'POST',
    headers: {
      Authorization: `token ${GITHUB_TOKEN}`,
      'User-Agent': 'burnitoken-monitoring-service',
      'Content-Type': 'application/json',
      'Content-Length': Buffer.byteLength(issueData, 'utf8'),
    },
  };

  return new Promise((resolve, reject) => {
    console.log(` Issue wird in Repository ${GITHUB_REPO} erstellt...`);

    const req = https.request(options, (res) => {
      let responseBody = '';
      res.on('data', (chunk) => {
        responseBody += chunk;
      });

      res.on('end', () => {
        const response = JSON.parse(responseBody);
        if (res.statusCode >= 200 && res.statusCode < 300) {
          console.log(`‚úÖ GitHub Issue erfolgreich erstellt: ${response.html_url}`);
          resolve(response.html_url);
        } else {
          const errorMessage = `Fehler beim Erstellen des GitHub Issues. Status: ${res.statusCode}, Antwort: ${responseBody}`;
          console.error(`‚ùå ${errorMessage}`);
          reject(new Error(errorMessage));
        }
      });
    });

    req.on('error', (error) => {
      const errorMessage = `Fehler bei der Anfrage an die GitHub API: ${error.message}`;
      console.error(`‚ùå ${errorMessage}`);
      reject(new Error(errorMessage));
    });

    req.write(issueData);
    req.end();
  });
}

module.exports = { createGitHubIssue };
