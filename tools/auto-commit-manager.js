#!/usr/bin/env node

/**
 * Auto-Commit Manager v2.0 - Batch Processing Edition
 *
 * Verarbeitet eine gro√üe Anzahl von √Ñnderungen durch intelligente Gruppierung,
 * Batch-Commits und detailliertes Logging.
 *
 * Kernfunktionen:
 * - Gruppiert √Ñnderungen nach Verzeichnis und Dateityp.
 * - Generiert aussagekr√§ftige, standardisierte Commit-Nachrichten.
 * - F√ºhrt Commits in Batches aus, um die Repository-Historie sauber zu halten.
 * - Bietet einen "Dry Run"-Modus zur sicheren Simulation.
 * - Integriert mit Alert- und Issue-Systemen f√ºr volle Transparenz.
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const { sendAlert } = require('./alert-service');
const { createGitHubIssue } = require('./github-issue-creator');

// --- KONFIGURATION ---
const CONFIG = {
    // Maximale Anzahl von Dateien pro Commit-Batch.
    BATCH_SIZE: 50,
    // Git-Branch, auf dem gearbeitet wird.
    BRANCH_NAME: 'main',
    // Verzeichnisse, die f√ºr die Gruppierung priorisiert werden.
    PRIORITY_DIRS: ['tools', 'scripts', '.github', 'src'],
    // Log-Datei f√ºr alle Operationen.
    LOG_FILE: path.join(__dirname, '.auto-commit.log'),
};

class AutoCommitManager {
    constructor(dryRun = true) {
        this.dryRun = dryRun;
        this.log(`üöÄ Auto-Commit Manager v2.0 initialisiert. Modus: ${this.dryRun ? 'DRY RUN' : 'EXECUTE'}`);
    }

    log(message, level = 'info') {
        const timestamp = new Date().toISOString();
        const logMessage = `[${timestamp}] [${level.toUpperCase()}] ${message}`;
        console.log(logMessage);
        fs.appendFileSync(CONFIG.LOG_FILE, logMessage + '\n', 'utf8');
    }

    async triggerCriticalError(functionName, error) {
        const errorMessage = `Kritischer Fehler in 'auto-commit-manager.js' in Funktion ${functionName}: ${error.message}`;
        this.log(errorMessage, 'error');
        await sendAlert({ message: errorMessage, level: 'critical', extra: { stack: error.stack } });
        await createGitHubIssue(
            `[Auto Commit] Kritischer Fehler in ${functionName}`,
            `**Ein unerwarteter Fehler ist im Auto Commit Manager aufgetreten.**\n\n**Funktion:** \`${functionName}\`\n**Fehler:**\n\`\`\`\n${error.message}\n\`\`\`\n\n**Stack Trace:**\n\`\`\`\n${error.stack}\n\`\`\``,
            ['bug', 'automation', 'autogenerated']
        );
    }

    getChangedFiles() {
        try {
            const statusOutput = execSync('git status --porcelain', { encoding: 'utf8' });
            if (!statusOutput.trim()) {
                return [];
            }
            return statusOutput.trim().split('\n').map(line => {
                // Extrahiert den Dateipfad und ignoriert den Status-Code (z.B. ' M ', 'A  ', '?? ')
                return line.substring(3);
            });
        } catch (error) {
            this.triggerCriticalError('getChangedFiles', error);
            return [];
        }
    }

    groupChanges(files) {
        const groups = {};

        files.forEach(file => {
            const dir = path.dirname(file);
            const ext = path.extname(file) || '.other';
            const mainDir = dir.split(path.sep)[0] || 'root';

            const groupKey = `${mainDir}_${ext}`;

            if (!groups[groupKey]) {
                groups[groupKey] = {
                    dir: mainDir,
                    ext: ext,
                    files: []
                };
            }
            groups[groupKey].files.push(file);
        });

        return Object.values(groups);
    }

    generateCommitMessage(group) {
        const fileCount = group.files.length;
        let scope = group.dir === '.' ? 'root' : group.dir;
        let type = 'chore'; // Standard-Typ

        // Heuristik f√ºr den Commit-Typ
        if (scope === 'tools' || scope === 'scripts') type = 'feat';
        if (group.ext === '.js') type = 'refactor';
        if (group.ext === '.css' || group.ext === '.html') type = 'style';
        if (group.ext === '.md') type = 'docs';
        if (scope === '.github') type = 'ci';

        const summary = `Update ${fileCount} ${group.ext} file(s)`;
        return `${type}(${scope}): ${summary}`;
    }

    async processCommits() {
        await sendAlert({ message: `Auto-Commit Prozess gestartet im ${this.dryRun ? 'Dry Run' : 'Execute'}-Modus.`, level: 'info', createIssue: false });

        const changedFiles = this.getChangedFiles();
        if (changedFiles.length === 0) {
            this.log('Keine √Ñnderungen zum Committen gefunden.');
            return;
        }

        this.log(`Insgesamt ${changedFiles.length} ge√§nderte Dateien gefunden. Beginne mit der Gruppierung...`);
        const groups = this.groupChanges(changedFiles);
        this.log(`${groups.length} logische Gruppen erstellt.`);

        let totalCommits = 0;

        for (const group of groups) {
            // Unterteile gro√üe Gruppen in kleinere Batches
            for (let i = 0; i < group.files.length; i += CONFIG.BATCH_SIZE) {
                const batchFiles = group.files.slice(i, i + CONFIG.BATCH_SIZE);
                const commitMessage = this.generateCommitMessage({ ...group, files: batchFiles });
                
                totalCommits++;
                this.log(`\n--- Batch ${totalCommits} ---`);
                this.log(`Commit-Nachricht: "${commitMessage}"`);
                this.log(`Dateien (${batchFiles.length}):`);
                batchFiles.forEach(f => this.log(`  - ${f}`));

                if (!this.dryRun) {
                    try {
                        const filesToAdd = batchFiles.map(f => `"${f}"`).join(' ');
                        execSync(`git add ${filesToAdd}`, { stdio: 'inherit' });
                        execSync(`git commit -m "${commitMessage}"`, { stdio: 'inherit' });
                        this.log('Batch erfolgreich committet.', 'success');
                    } catch (error) {
                        this.log(`Fehler beim Committen von Batch ${totalCommits}. √úberspringe...`, 'error');
                        await this.triggerCriticalError('processCommits (commit)', error);
                    }
                }
            }
        }

        this.log(`\n--- Zusammenfassung ---`);
        this.log(`Verarbeitung abgeschlossen. ${totalCommits} ${this.dryRun ? 'simulierte' : 'erstellte'} Commits.`);

        if (!this.dryRun && totalCommits > 0) {
            this.log('Pushe alle Commits zum Remote-Repository...');
            try {
                execSync(`git push origin ${CONFIG.BRANCH_NAME}`, { stdio: 'inherit' });
                this.log('Push erfolgreich!', 'success');
                await sendAlert({ message: `Auto-Commit Prozess erfolgreich. ${totalCommits} Batches committet und gepusht.`, level: 'success' });
            } catch (error) {
                this.log('Push fehlgeschlagen!', 'error');
                await this.triggerCriticalError('processCommits (push)', error);
            }
        } else if (this.dryRun) {
             await sendAlert({ message: `Auto-Commit Dry Run abgeschlossen. ${totalCommits} Batches simuliert.`, level: 'info' });
        }
    }
}

// --- CLI-Interface ---
if (require.main === module) {
    const args = process.argv.slice(2);
    const isDryRun = !args.includes('--execute');

    const manager = new AutoCommitManager(isDryRun);

    manager.processCommits().catch(async (error) => {
        console.error('Unerwarteter Fehler im Hauptprozess:', error);
        await manager.triggerCriticalError('main', error);
        process.exit(1);
    });
}

module.exports = AutoCommitManager;
