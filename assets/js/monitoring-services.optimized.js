class MonitoringServices { constructor(config = {}) { this.config = { sentry: { dsn: process.env.SENTRY_DSN || config.sentryDsn, environment: process.env.NODE_ENV || 'production', release: process.env.GITHUB_SHA || 'unknown', tracesSampleRate: 1.0, enabled: Boolean(process.env.SENTRY_DSN || config.sentryDsn), }, uptimeRobot: { apiKey: process.env.UPTIMEROBOT_API_KEY || config.uptimeRobotApiKey, monitors: [ { name: 'BurniToken Website', url: 'https: type: 'http', interval: 300, }, { name: 'BurniToken API Health', url: 'https: type: 'http', interval: 300, }, ], enabled: Boolean(process.env.UPTIMEROBOT_API_KEY || config.uptimeRobotApiKey), }, status: { endpoints: ['/api/health', '/api/status', '/assets/js/price-oracle.js'], checkInterval: 60000, timeout: 10000, }, performance: { enableWebVitals: true, enableResourceTiming: true, enableNavigationTiming: true, reportInterval: 30000, }, notifications: { slack: { webhookUrl: process.env.SLACK_WEBHOOK_URL || config.slackWebhook, channel: '#alerts', enabled: Boolean(process.env.SLACK_WEBHOOK_URL || config.slackWebhook), }, discord: { webhookUrl: process.env.DISCORD_WEBHOOK_URL || config.discordWebhook, enabled: Boolean(process.env.DISCORD_WEBHOOK_URL || config.discordWebhook), }, email: { enabled: false, }, }, ...config, }; this.state = { initialized: false, services: { sentry: { status: 'idle', lastCheck: null }, uptimeRobot: { status: 'idle', lastCheck: null }, customStatus: { status: 'idle', lastCheck: null }, }, errors: [], metrics: new Map(), alerts: [], }; this.intervals = new Map(); this.init()} async init() { console.log('🔍 Initializing Monitoring Services...'); try { if (this.config.sentry.enabled)  await this.initSentry()} if (this.config.uptimeRobot.enabled) { await this.initUptimeRobot()} await this.initCustomStatus(); if (this.config.performance.enableWebVitals) { await this.initPerformanceMonitoring()} this.startMonitoring(); this.state.initialized = true; console.log('✅ Monitoring Services initialized successfully')} catch (error) { console.error('❌ Failed to initialize monitoring services:', error); this.reportError('INIT_ERROR', error)} } async initSentry() { if (typeof window !== 'undefined' && window.Sentry) { window.Sentry.init({ dsn: this.config.sentry.dsn, environment: this.config.sentry.environment, release: this.config.sentry.release, tracesSampleRate: this.config.sentry.tracesSampleRate, beforeSend: (event) => this.sentryBeforeSend(event), }); this.state.services.sentry.status = 'active'; console.log('🔍 Sentry initialized for browser')} } sentryBeforeSend(event) { if (event.exception) { const error = event.exception.values[0]; if (error.value?.includes('Non-Error promise rejection captured')) { return null} event.tags = { ...event.tags, component: 'burnitoken-website', version: this.config.sentry.release, }; event.extra = { ...event.extra, url: window.location.href, userAgent: navigator.userAgent, timestamp: new Date().toISOString(), }} return event} async initUptimeRobot() { this.state.services.uptimeRobot.status = 'configured'; console.log('📊 UptimeRobot monitoring configured')} async initCustomStatus() { this.state.services.customStatus.status = 'active'; console.log('🏥 Custom status monitoring initialized')} async initPerformanceMonitoring() { if (typeof window !== 'undefined') { this.setupWebVitals(); if (this.config.performance.enableResourceTiming) { this.setupResourceTiming()} if (this.config.performance.enableNavigationTiming) { this.setupNavigationTiming()} console.log('📈 Performance monitoring initialized')} } setupWebVitals() { const vitals = ['FCP', 'LCP', 'FID', 'CLS', 'TTFB']; vitals.forEach((vital) => { this.observeVital(vital)})} observeVital(vitalName) { try { const observer = new PerformanceObserver((list) => { list.getEntries().forEach((entry) => { this.recordMetric(`web_vital_${vitalName.toLowerCase()}`, { value: entry.value || entry.duration, timestamp: Date.now(), url: window.location.href, })})}); observer.observe({ entryTypes: [ 'paint', 'largest-contentful-paint', 'first-input', 'layout-shift', 'navigation', ], })} catch (error) { console.warn(`Could not observe ${vitalName}:`, error)} } setupResourceTiming() { const observer = new PerformanceObserver((list) => { list.getEntries().forEach((entry) => { if (entry.duration > 1000) { this.recordMetric('slow_resource', { name: entry.name, duration: entry.duration, size: entry.transferSize, timestamp: Date.now(), })} })}); observer.observe({ entryTypes: ['resource'] })} setupNavigationTiming() { window.addEventListener('load', () => { const nav = performance.getEntriesByType('navigation')[0]; if (nav) { this.recordMetric('page_load', { domContentLoaded: nav.domContentLoadedEventEnd - nav.domContentLoadedEventStart, loadComplete: nav.loadEventEnd - nav.loadEventStart, totalTime: nav.loadEventEnd - nav.fetchStart, timestamp: Date.now(), })} })} startMonitoring() { const statusInterval = setInterval(() => { this.checkCustomStatus()}, this.config.status.checkInterval); this.intervals.set('customStatus', statusInterval); if (this.config.performance.enableWebVitals) { const metricsInterval = setInterval(() => { this.reportMetrics()}, this.config.performance.reportInterval); this.intervals.set('metrics', metricsInterval)} console.log('🔄 Monitoring loops started')} async checkCustomStatus() { const results = []; for (const endpoint of this.config.status.endpoints) { try { const startTime = Date.now(); const response = await fetch(endpoint, { method: 'HEAD', timeout: this.config.status.timeout, }); const responseTime = Date.now() - startTime; results.push({ endpoint, status: response.ok ? 'healthy' : 'unhealthy', responseTime, statusCode: response.status, timestamp: Date.now(), }); if (!response.ok) { this.createAlert({ type: 'endpoint_unhealthy', message: `Endpoint ${endpoint} returned ${response.status}`, severity: 'warning', data: { endpoint, statusCode: response.status }, })} } catch (error) { results.push({ endpoint, status: 'error', error: error.message, timestamp: Date.now(), }); this.createAlert({ type: 'endpoint_error', message: `Endpoint ${endpoint} failed: ${error.message}`, severity: 'critical', data: { endpoint, error: error.message }, })} } this.state.services.customStatus.lastCheck = Date.now(); this.recordMetric('status_check', results)} recordMetric(name, data) { if (!this.state.metrics.has(name)) { this.state.metrics.set(name, [])} const metrics = this.state.metrics.get(name); metrics.push({ ...data, timestamp: data.timestamp || Date.now(), }); if (metrics.length > 100) { metrics.splice(0, metrics.length - 100)} } createAlert(alert) { const alertObj = { id: `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, ...alert, timestamp: Date.now(), }; this.state.alerts.push(alertObj); this.sendNotifications(alertObj); if (this.state.alerts.length > 50) { this.state.alerts.splice(0, this.state.alerts.length - 50)} console.warn('🚨 Alert created:', alertObj)} async sendNotifications(alert) { const promises = []; if (this.config.notifications.slack.enabled) { promises.push(this.sendSlackNotification(alert))} if (this.config.notifications.discord.enabled) { promises.push(this.sendDiscordNotification(alert))} await Promise.allSettled(promises)} async sendSlackNotification(alert) { try { const payload = { channel: this.config.notifications.slack.channel, text: `🚨 BurniToken Alert: ${alert.message}`, attachments: [ { color: alert.severity === 'critical' ? 'danger' : 'warning', fields: [ { title: 'Type', value: alert.type, short: true }, { title: 'Severity', value: alert.severity, short: true }, { title: 'Timestamp', value: new Date(alert.timestamp).toISOString(), short: false }, ], }, ], }; await fetch(this.config.notifications.slack.webhookUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload), })} catch (error) { console.error('Failed to send Slack notification:', error)} } async sendDiscordNotification(alert) { try { const embed = { title: '🚨 BurniToken Alert', description: alert.message, color: alert.severity === 'critical' ? 0xff0000 : 0xffa500, fields: [ { name: 'Type', value: alert.type, inline: true }, { name: 'Severity', value: alert.severity, inline: true }, { name: 'Timestamp', value: new Date(alert.timestamp).toISOString(), inline: false }, ], timestamp: new Date(alert.timestamp).toISOString(), }; await fetch(this.config.notifications.discord.webhookUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ embeds: [embed] }), })} catch (error) { console.error('Failed to send Discord notification:', error)} } reportError(type, error) { this.state.errors.push({ type, message: error.message, stack: error.stack, timestamp: Date.now(), }); if (this.config.sentry.enabled && window.Sentry) { window.Sentry.captureException(error, { tags: { type }, extra: { component: 'monitoring-services' }, })} this.createAlert({ type: 'monitoring_error', message: `Monitoring system error: ${error.message}`, severity: 'critical', data: { type, error: error.message }, })} async reportMetrics() { const metricsToReport = {}; for (const [name, data] of this.state.metrics.entries()) { if (data.length > 0) { metricsToReport[name] = { count: data.length, latest: data[data.length - 1], summary: this.summarizeMetrics(data), }} } if (Object.keys(metricsToReport).length > 0) { console.log('📊 Reporting metrics:', metricsToReport); try { await fetch('/api/metrics', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ timestamp: Date.now(), metrics: metricsToReport, }), })} catch (error) { } } } summarizeMetrics(data) { if (data.length === 0) return null; const values = data.map((d) => d.value || d.duration || 0).filter((v) => typeof v === 'number'); if (values.length === 0) return null; const sorted = values.sort((a, b) => a - b); return { count: values.length, min: sorted[0], max: sorted[sorted.length - 1], avg: values.reduce((a, b) => a + b, 0) / values.length, p50: sorted[Math.floor(sorted.length * 0.5)], p95: sorted[Math.floor(sorted.length * 0.95)], p99: sorted[Math.floor(sorted.length * 0.99)], }} getState() { return { ...this.state }} getMetrics(name) { return name ? this.state.metrics.get(name) : Object.fromEntries(this.state.metrics)} getAlerts(limit = 10) { return this.state.alerts.slice(-limit)} async healthCheck() { const services = {}; for (const [name, service] of Object.entries(this.state.services)) { services[name] = { status: service.status, lastCheck: service.lastCheck, healthy: service.status === 'active' || service.status === 'configured', }} return { overall: Object.values(services).every((s) => s.healthy) ? 'healthy' : 'degraded', services, uptime: this.state.initialized ? Date.now() - this.state.initialized : 0, timestamp: Date.now(), }} destroy() { for (const [name, intervalId] of this.intervals.entries()) { clearInterval(intervalId)} this.intervals.clear(); this.state.metrics.clear(); this.state.alerts = []; this.state.errors = []; console.log('💥 Monitoring Services destroyed')} } window.MonitoringServices = MonitoringServices; if (typeof window !== 'undefined') { window.addEventListener('DOMContentLoaded', () => { window.burniMonitoring = new MonitoringServices()})} function Sentry(...args) { console.log('Sentry aufgerufen mit Argumenten:', args); return undefined} function UptimeRobot(...args) { console.log('UptimeRobot aufgerufen mit Argumenten:', args); return undefined}  function Map(...args) { console.log('Map aufgerufen mit Argumenten:', args); return undefined} function init(...args) { console.log('init aufgerufen mit Argumenten:', args); return undefined}   function initSentry(...args) { console.log('initSentry aufgerufen mit Argumenten:', args); return undefined} function initUptimeRobot(...args) { console.log('initUptimeRobot aufgerufen mit Argumenten:', args); return undefined} function initCustomStatus(...args) { console.log('initCustomStatus aufgerufen mit Argumenten:', args); return undefined} function initPerformanceMonitoring(...args) { console.log('initPerformanceMonitoring aufgerufen mit Argumenten:', args); return undefined} function startMonitoring(...args) { console.log('startMonitoring aufgerufen mit Argumenten:', args); return undefined}   function reportError(...args) { console.log('reportError aufgerufen mit Argumenten:', args); return undefined} function sentryBeforeSend(...args) { console.log('sentryBeforeSend aufgerufen mit Argumenten:', args); return undefined} function includes(...args) { console.log('includes aufgerufen mit Argumenten:', args); return undefined} function toISOString(...args) { console.log('toISOString aufgerufen mit Argumenten:', args); return undefined} function setupWebVitals(...args) { console.log('setupWebVitals aufgerufen mit Argumenten:', args); return undefined} function setupResourceTiming(...args) { console.log('setupResourceTiming aufgerufen mit Argumenten:', args); return undefined} function setupNavigationTiming(...args) { console.log('setupNavigationTiming aufgerufen mit Argumenten:', args); return undefined} function forEach(...args) { console.log('forEach aufgerufen mit Argumenten:', args); return undefined} function observeVital(...args) { console.log('observeVital aufgerufen mit Argumenten:', args); return undefined} function PerformanceObserver(...args) { console.log('PerformanceObserver aufgerufen mit Argumenten:', args); return undefined} function getEntries(...args) { console.log('getEntries aufgerufen mit Argumenten:', args); return undefined} function recordMetric(...args) { console.log('recordMetric aufgerufen mit Argumenten:', args); return undefined} function toLowerCase(...args) { console.log('toLowerCase aufgerufen mit Argumenten:', args); return undefined} function now(...args) { console.log('now aufgerufen mit Argumenten:', args); return undefined} function observe(...args) { console.log('observe aufgerufen mit Argumenten:', args); return undefined}  function addEventListener(...args) { console.log('addEventListener aufgerufen mit Argumenten:', args); return undefined} function getEntriesByType(...args) { console.log('getEntriesByType aufgerufen mit Argumenten:', args); return undefined} function checkCustomStatus(...args) { console.log('checkCustomStatus aufgerufen mit Argumenten:', args); return undefined} function set(...args) { console.log('set aufgerufen mit Argumenten:', args); return undefined} function reportMetrics(...args) { console.log('reportMetrics aufgerufen mit Argumenten:', args); return undefined}  function fetch(...args) { console.log('fetch aufgerufen mit Argumenten:', args); return undefined} function push(...args) { console.log('push aufgerufen mit Argumenten:', args); return undefined} function createAlert(...args) { console.log('createAlert aufgerufen mit Argumenten:', args); return undefined} function has(...args) { console.log('has aufgerufen mit Argumenten:', args); return undefined} function get(...args) { console.log('get aufgerufen mit Argumenten:', args); return undefined} function splice(...args) { console.log('splice aufgerufen mit Argumenten:', args); return undefined} function random(...args) { console.log('random aufgerufen mit Argumenten:', args); return undefined} function toString(...args) { console.log('toString aufgerufen mit Argumenten:', args); return undefined} function substr(...args) { console.log('substr aufgerufen mit Argumenten:', args); return undefined} function sendNotifications(...args) { console.log('sendNotifications aufgerufen mit Argumenten:', args); return undefined} function sendSlackNotification(...args) { console.log('sendSlackNotification aufgerufen mit Argumenten:', args); return undefined} function sendDiscordNotification(...args) { console.log('sendDiscordNotification aufgerufen mit Argumenten:', args); return undefined} function allSettled(...args) { console.log('allSettled aufgerufen mit Argumenten:', args); return undefined} function stringify(...args) { console.log('stringify aufgerufen mit Argumenten:', args); return undefined} function captureException(...args) { console.log('captureException aufgerufen mit Argumenten:', args); return undefined} function entries(...args) { console.log('entries aufgerufen mit Argumenten:', args); return undefined} function summarizeMetrics(...args) { console.log('summarizeMetrics aufgerufen mit Argumenten:', args); return undefined} function keys(...args) { console.log('keys aufgerufen mit Argumenten:', args); return undefined} function endpoint(...args) { console.log('endpoint aufgerufen mit Argumenten:', args); return undefined} function map(...args) { console.log('map aufgerufen mit Argumenten:', args); return undefined} function filter(...args) { console.log('filter aufgerufen mit Argumenten:', args); return undefined} function sort(...args) { console.log('sort aufgerufen mit Argumenten:', args); return undefined} function reduce(...args) { console.log('reduce aufgerufen mit Argumenten:', args); return undefined} function floor(...args) { console.log('floor aufgerufen mit Argumenten:', args); return undefined} function getState(...args) { console.log('getState aufgerufen mit Argumenten:', args); return undefined} function getMetrics(...args) { console.log('getMetrics aufgerufen mit Argumenten:', args); return undefined} function fromEntries(...args) { console.log('fromEntries aufgerufen mit Argumenten:', args); return undefined} function getAlerts(...args) { console.log('getAlerts aufgerufen mit Argumenten:', args); return undefined} function slice(...args) { console.log('slice aufgerufen mit Argumenten:', args); return undefined} function healthCheck(...args) { console.log('healthCheck aufgerufen mit Argumenten:', args); return undefined} function values(...args) { console.log('values aufgerufen mit Argumenten:', args); return undefined} function every(...args) { console.log('every aufgerufen mit Argumenten:', args); return undefined} function destroy(...args) { console.log('destroy aufgerufen mit Argumenten:', args); return undefined} function clear(...args) { console.log('clear aufgerufen mit Argumenten:', args); return undefined} function MonitoringServices(...args) { console.log('MonitoringServices aufgerufen mit Argumenten:', args); return undefined}